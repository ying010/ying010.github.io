import{_ as l,n as p,p as i,a0 as e}from"./framework-76e35361.js";const t={},o=e("<p>线程状态</p><p>synchronized：</p><p>​ 锁对象，以执行某一段代码；</p><p>​ 锁普通方法等于锁this，锁静态方法相当于锁当前类.class的对象（类加载器加载的class对象）</p><p>​ hotspot VM中实现方式是对象头上有两位表示锁标识</p><p>​ 可重入锁</p><p>​ sync(Object)</p><p>​ markword记录线程ID(偏向锁)</p><p>​ 如果线程争用，升级为自旋锁</p><p>​ 10次之后，升级为重量锁 - OS</p><p>​ 加锁代码，执行时间短，线程数少用自旋锁；执行时间长、线程数多用系统锁。</p><ul><li><p>线程的概念、启动方式、常用方法</p></li><li><p>synchronized(Object)</p><ul><li>不能用String常量 Integer Long 等</li></ul></li><li><p>线程同步</p><p>-synchronized</p><ul><li>锁的是对象不是代码</li><li>不些锁定对象锁this；锁静态方法锁 XX.class</li><li>锁定方法 非锁定方法 同时执行</li><li>锁升级 <ul><li>偏向锁 -&gt; 自旋锁 -&gt; 重量级锁</li></ul></li></ul></li></ul><p>volatile:</p><ul><li>保证线程可见性 <ul><li>MESI</li><li>缓存一致性协议</li></ul></li><li>禁止指令重排序(CPU) ：指令重排序表现为编译后的汇编指令重新排序 <ul><li>DCL单例</li><li>Double Check Lock</li></ul></li></ul><p>volatile不保证原子性；synchronized不阻止指令重排</p><p>如果不加volatile但是线程可见，1、线程取线程缓存数据才会出现可见性问题，如果都是直接取内存数据是没问题的，如果线程操作的数据次数较少时不触发缓存。2、由于其他语句触发了MESI(缓存一致性协议)，例如：System.out.println会由于有synchronized而触发MESI。</p><p>CAS（无锁优化 自旋）</p><p>Atomic前缀开头的类都是CAS实现</p><ul><li><p>Compare And Set</p></li><li><p>cas(V, Expected, NewValue)</p><ul><li><p>if V==e</p><p>v=NewValue</p><p>otherwise try again or fail</p></li><li><p>CPU原语支持</p></li></ul></li><li><p>ABA问题</p><ul><li>加Version</li></ul></li></ul><p>CountDownLatch</p><p>CyclicBarrier</p><p>Phaser</p><p>ReentrantReadWriteLock</p><p>读写锁，读读不排斥，写排斥。如果是一个线程获取到读锁，每次上个读锁业务执行完毕前就续上另一个读锁线程，那期间产生的写锁就加不进去，造成类似于写死锁的现象。</p><p>semaphore</p><ul><li>限流</li><li></li></ul>",26),n=[o];function c(s,r){return p(),i("div",null,n)}const u=l(t,[["render",c],["__file","demo.html.vue"]]);export{u as default};
